<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML><HEAD>
<BODY bgColor=white>

<h3> Implementing the Component Model </h3>

<p>
The scheduling subsystem can be in one of five states: 
new, initialized, executing, error or stopped. The state model 
for the scheduling subsystem is shown below.

<p>
<img src = ComponentState.gif alt = component state model />

<p>
The “normal” path is from a newly constructed object, to the 
initialized state, to the executing state. During execution, 
a cleanUp command takes it to the stopped state, where the 
component is destroyed.

<p>
The constructor constructs the MasterScheduler object which implements
the component model's lifecycle methods.  The newly created object
is placed in the "new" state.

<p>
The initialize method completely initializes the scheduling subsystem.
It cannot be called if the scheduling subsystem is in the "executing"
state.  In addition the component name and container services must
be provided before initialization can occur.  If any error occurs 
during initialization, the scheduling subsystem is placed in the "error"
state and an exception is thrown.  After initialization this object is
not active; nothing begins executing until the execute method is called.


<p>
The initialize method performs the following activities.
<ul>
<li> Creates all proxy objects, either in real or simulation mode.  These
		include the archive, pipeline, telescope operator, and PI proxies.
<li> Creates the dispatcher and clock, either in real or simulation mode.
<li> Reads the list of scheduling policies from the archive.
<li> Gets the list of commissioned antennas from the archive.
<li> Creates the Project Manager object.
<li> Creates an empty queue of SchedBlocks.
<li> Create an empty list of Schedulers.
<li> Create a periodic action object.
<li> If mode is real and lockfile is null, check for the existence
	of a lockfile.  If it exists, an exception is thrown indicating
	that a MasterScheduler object is already running and this initialized
	object cannot be executed.  If the lockfile exists and there is no
	MasterScheduler object running, the lockfile must be manually removed
	before this object can be executed.  In these circumstances, this object 
	is not placed in an error state.
<li> Set state to "initialized".
</ul>

<p>
The execute method begins the process of executing the scheduling subsystem.
If any error occurs during execution, the scheduling subsystem is placed in 
the "error" state and an exception is thrown. The execute method starts the
project manager; however, it does not start the scheduling activity.  That
must be explicitly done via the "startScheduling" method.

<p>
The execute method performs the following activities.

<ul>
<li> Creates a lockfile to prevent any other MasterScheduler from executing.
<li> Get the full set of SBs from the archive that have not been completed
	and place them in the master SB queue.
<li> Form a unique list of SB-ids from the master SB queue and give those to
	Project Manager to be added to its list of projects.
<li> Get the antenna state from the control system.
<li> Get the state model from the control system.
<li> Get the necessary notification channels.
<li> Set up the notification channel receivers for the Project Manager.
<li> Set up the proper listeners on the notification channels.
<li> Start the Project Manager thread.
<li> Start the perodic action object.
</ul>

<p>
The cleanUp method tells all threads in the subsystem to stop and deletes
the lockfile.  It then waits for all threads to stop, sets all object references
to null and sets the state to "stopped".  

<p>
The aboutToAbort method merely calls the cleanUp method.  The various actions
in the cleanUp method are arranged in order of importance.  If the execution
gets to the point of waiting for all threads to stop, the system will be in a
relatively safe state and it should be ready to resume operations without
manual inteventation.


</BODY></HTML>
