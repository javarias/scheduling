/*
 * ALMA - Atacama Large Millimeter Array
 * (c) European Southern Observatory, 2002
 * (c) Associated Universities Inc., 2002
 * Copyright by ESO (in the framework of the ALMA collaboration),
 * Copyright by AUI (in the framework of the ALMA collaboration),
 * All rights reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307  USA
 *
 * $Id: SchedulingArray.idl,v 1.4 2010/10/13 15:55:31 javarias Exp $
 */

#ifndef _SCHEDULINGARRAY_IDL_
#define _SCHEDULINGARRAY_IDL_

#include <acscomponent.idl>
#include <acserr.idl>
#include <acscommon.idl>
#include <SchedulingExceptions.idl>
#include <SchedulingArrayExceptions.idl>

#pragma prefix "alma"

module scheduling {

//HACK: This file is included in SchedulingMaster.idl  the enum defined here has a
// conflict with another enum defined in SchedulingMaster.idl
//Added _I, jacorb parser doesn't support very well modules inside modules
   enum ArraySchedulerMode{
      INTERACTIVE_I,
   	  DYNAMIC_PASSIVE_I,
      DYNAMIC_ACTIVE_I,
      TIME_BASED_I,
      MANUAL_I
   };

    typedef sequence<ArraySchedulerMode> ArraySchedulerModeSeq;
    
    enum ArraySchedulerLifecycleType {
        NORMAL,
        COMMISSIONING
    };

    typedef string SchedBlockUID;
    typedef sequence<SchedBlockUID> SchedBlockUIDSeq;

    struct SchedBlockScore {
        SchedBlockUID uid;
        double score;
        unsigned long rank;
    };
    typedef sequence<SchedBlockScore> SchedBlockScoreSeq;

	struct SchedBlockQueueItem {
		long long timestamp;
		SchedBlockUID uid;
	};
    typedef sequence<SchedBlockQueueItem> SchedBlockQueueItemSeq;

    /**
     * Inside the Array component, a thread executes SchedBlocks as soon
     * they are available in a queue.
     * This callback reports state changes in the execution.
     */
    interface SchedBlockExecutionCallback : ACS::OffShoot {

        /**
         * Report a change of status in a SB execution.
         */
        oneway void report(in SchedBlockQueueItem item, in string newState,
        	in ACSErr::Completion completion);
    };

    /**
     * Types of operation that can be performed in the Scheduler Array
     * queue. This enumeration is used in the queue monitoring callback.
     */
    enum QueueOperation {
        PUSH,
        PULL,
        UP,
        DOWN,
        REMOVE,
        STATE_CHANGE,
        PUSH_MANY,
        REMOVE_MANY
    };
    
    /**
     * Inside the Array component, a queue is used to hold the SchedBlocks
     * scheduled for execution. This callback reports changes in the queue.
     */
    interface SchedBlockQueueCallback : ACS::OffShoot {
        /**
         * Report a change in the SB queue.
         */
        oneway void report(in ACS::Time timestamp, in QueueOperation operation,
                           in SchedBlockUIDSeq uids, in string newState);
    };

    /**
     * Interface to manage the Array's internal SchedBlock execution queue.
     */
    interface SchedBlockQueueManager {
        void push(in SchedBlockQueueItem item);
        SchedBlockQueueItem pull();
        void moveUp(in SchedBlockQueueItem item); 
        void moveDown(in SchedBlockQueueItem item);
        void delete(in SchedBlockQueueItem item);
        SchedBlockQueueItemSeq getQueue();
        long getQueueCapacity();
        void monitorQueue(in string monitorName, in SchedBlockQueueCallback callback);
        SchedBlockQueueItemSeq getExecutedQueue();
    };

    /**
     * Interface to control the Array's SchedBlock execution thread.
     */
    interface SchedBlockExecutionManager {
        void start();
        void stop();
        SchedBlockUID getRunningSchedBlock() raises (SchedulingArrayExceptions::NoRunningSchedBlockEx);
        void stopRunningSchedBlock();
        void abortRunningSchedBlock();
        void monitorExecution(in string monitorName, in SchedBlockExecutionCallback callback);
    };

    /**
     * Interface to run the Dynamic Scheduling Algorithm.
     */
    interface DSA {
        SchedBlockScoreSeq run();
    };

    interface Array : ACS::ACSComponent, SchedBlockQueueManager,
                      SchedBlockExecutionManager, DSA {
        void configure(in string arrayName, in ArraySchedulerModeSeq modes,
        	in ArraySchedulerLifecycleType lifecycleType);
        ArraySchedulerModeSeq getModes();
        ArraySchedulerLifecycleType getLifecycleType();
    };

};
#endif // _SCHEDULINGARRAY_IDL_
